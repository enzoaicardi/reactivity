class t{static t=Symbol();static i=Symbol();static h=Symbol();static o=Symbol();static l=Symbol();static u=Symbol()}class s{value;[t.t];[t.i];static[t.h]=null;static[t.o]=null;static use=(t,...i)=>new s(t).use(...i);constructor(s){this.value=s,this[t.t]=new Set,this[t.i]=!1}add(s){this[t.t].add(s),s[t.t].add(this)}use(...i){s[t.o]=s[t.h],s[t.h]=this[t.i]?null:this,this[t.i]||(this[t.i]=!0);const e=this.value(...i);return s[t.h]=s[t.o],e}delete(s){this[t.t].delete(s),s[t.t].delete(this)}clear(){for(const s of this[t.t])s[t.t].delete(this);this[t.t].clear()}}class i{value;[t.t];constructor(s){void 0!==s&&(this.value=s),this[t.t]=new Set}get(){const i=s[t.h];return i&&(this[t.t].add(i),i[t.t].add(this)),this.value}set(s){if(this.value!==s){this.value=s;for(const s of this[t.t])s.use()}return this.value}delete(s){this[t.t].delete(s),s[t.t].delete(this)}clear(){for(const s of this[t.t])s[t.t].delete(this);this[t.t].clear()}}class e extends i{[t.l];[t.u];entry;constructor(i){super(),this[t.l]=i,this[t.u]=new s((()=>this.set(this.entry))),this[t.u].use()}set(s){return this.entry=s,s=this[t.l](s),super.set(s)}clear(){delete this.entry,this[t.u]&&this[t.u].clear(),super.clear()}}export{e as ComputedSignal,s as Reactive,i as Signal};
