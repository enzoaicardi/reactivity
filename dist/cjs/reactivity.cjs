"use strict";class t{value;t;i;static h=null;static o=null;static use=(s,...e)=>new t(s).use(...e);constructor(t){this.value=t,this.t=new Set,this.i=!1}add(t){this.t.add(t),t.t.add(this)}use(...s){if(this.i)return this.value(...s);{this.i=!0,t.o=t.h,t.h=this;const e=this.value(...s);return t.h=t.o,e}}delete(t){if(t)this.t.delete(t),t.t.delete(this);else{for(const t of this.t)t.t.delete(this);this.t.clear()}}}class s{value;t;constructor(t){void 0!==t&&(this.value=t),this.t=new Set}get(){const s=t.h;return s&&(this.t.add(s),s.t.add(this)),this.value}set(t){if(this.value!==t){this.value=t;for(const t of this.t)t.value()}return this.value}delete(t){if(t)this.t.delete(t),t.t.delete(this);else{for(const t of this.t)t.t.delete(this);this.t.clear()}}}exports.ComputedSignal=class extends s{u;l;entry;constructor(s){super(),this.u=s,this.l=new t((()=>this.set(this.entry))),this.l.use()}set(t){return this.entry=t,t=this.u(t),super.set(t)}delete(t){delete this.entry,!t&&this.l&&(this.l.delete(),delete this.l),super.delete(t)}},exports.Reactive=t,exports.Signal=s;
