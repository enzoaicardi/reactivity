// Generated by dts-bundle-generator v9.5.1

export declare class Signal<Type> {
	value: Type;
	dependencies: Set<Reactive<AnyFunction>>;
	/**
	 * create a signal
	 * @param {Type?} value the inital signal state
	 * @param {Reactive<AnyFunction>[]?} reactives the dependencies
	 */
	constructor(value?: Type, reactives?: Reactive<AnyFunction>[]);
	/**
	 * method used to retrieve the value of a signal
	 * while adding the current reactive function to the dependencies
	 * @returns {Type} the signal value
	 */
	get(): Type;
	/**
	 * method used to update the value of a signal
	 * while triggering all the reactive functions in the dependencies
	 * @param {Type} value the new signal value
	 */
	set(value: Type): Type;
	/**
	 * method used to update the value of a signal using a custom function
	 * while triggering all the reactive functions in the dependencies
	 * @param {Function} callback the new signal value
	 */
	compute(callback: (value: Type) => Type): void;
	/**
	 * method used to manually add reactive functions to signal dependencies
	 * @param {Reactive<AnyFunction>[]} reactives reactive functions to add as signal dependency
	 */
	add(...reactives: Reactive<AnyFunction>[]): void;
	/**
	 * method used to remove reactive functions from dependencies
	 * @param {Reactive<AnyFunction>[]} reactives reactive functions to be cleared
	 */
	delete(...reactives: Reactive<AnyFunction>[]): void;
	/**
	 * method used to remove all reactive functions from dependencies
	 */
	clear(): void;
}
export type AnyFunction = (...args: any) => any;
export declare class Reactive<FunctionType extends AnyFunction = AnyFunction> {
	value: FunctionType;
	dependencies: Set<Signal<any>>;
	/**
	 * create a reactive function
	 * @param {Function} callback the reactive callback
	 * @param {Signal<any>[]?} signals the dependencies
	 */
	constructor(callback: FunctionType, signals?: Signal<any>[]);
	/**
	 * method used to trigger the reactive function
	 * while changing the value of the current reactive function to null
	 * @param {Parameters<FunctionType>} args the reactive function arguments
	 * @returns {ReturnType<FunctionType>} the reative function result
	 */
	call(...args: Parameters<FunctionType>): ReturnType<FunctionType>;
	/**
	 * method used to trigger the reactive function
	 * while changing the value of the current reactive function to this
	 * @param {Parameters<FunctionType>} args the reactive function arguments
	 * @returns {ReturnType<FunctionType>} the reative function result
	 */
	bind(...args: Parameters<FunctionType>): ReturnType<FunctionType>;
	/**
	 * method used to manually add reactive function to signals dependencies
	 * @param {Signal[]} signals the signals in which to add the dependency
	 */
	add(...signals: Signal<any>[]): void;
	/**
	 * method used to remove signals from dependencies
	 * @param {Signal[]} signals the signals to be cleared
	 */
	delete(...signals: Signal<any>[]): void;
	/**
	 * method used to remove all signals from dependencies
	 */
	clear(): void;
}

export {};
